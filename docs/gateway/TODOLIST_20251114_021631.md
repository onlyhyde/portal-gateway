# Portal Gateway - Implementation Todo List

**Document Created**: 2025-11-14 02:16:31
**Version**: 1.0
**Status**: ðŸ“‹ Ready for Execution

---

## ðŸ“‹ Overview

This document provides a detailed, week-by-week implementation plan for the Portal Gateway project.

**Timeline**: 12 weeks (3 months)
**Team Size**: 2-3 developers
**Methodology**: Agile with 1-week sprints

---

## ðŸŽ¯ Milestones

```
Week 1-2:   âš™ï¸  Foundation Setup
Week 3-4:   ðŸ” Core Security Features
Week 5-6:   ðŸ“Š Observability & Reliability
Week 7-8:   ðŸš€ MVP Release & Testing
Week 9-10:  ðŸ¤– AI Optimization
Week 11-12: ðŸ¢ Production Hardening
```

---

## ðŸ“… Phase 1: Foundation (Weeks 1-2)

### Week 1: Project Bootstrap & Basic Proxy

#### Task 1.1: Project Setup
**Priority**: P0
**Effort**: 0.5 days
**Assignee**: TBD
**Dependencies**: None

**Description**: Initialize Go project with proper structure and tooling

**Checklist**:
- [ ] Create GitHub repository
- [ ] Initialize Go module (`go mod init`)
- [ ] Set up directory structure (cmd/, internal/, pkg/)
- [ ] Create Makefile with common tasks
- [ ] Set up .gitignore
- [ ] Initialize pre-commit hooks (gofmt, go vet)
- [ ] Create README.md with project overview

**Acceptance Criteria**:
- âœ… `go build` succeeds
- âœ… Project structure matches ARCHITECTURE.md
- âœ… Makefile has: build, test, lint, run targets
- âœ… README explains project setup

**Commands**:
```bash
mkdir portal-gateway && cd portal-gateway
go mod init github.com/yourusername/portal-gateway
mkdir -p cmd/gateway internal pkg configs deployments docs
make build
```

---

#### Task 1.2: HTTP Server Skeleton
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 1.1

**Description**: Create basic HTTP server with health check endpoint

**Checklist**:
- [ ] Create `internal/server/server.go`
- [ ] Implement HTTP server with graceful shutdown
- [ ] Add `/health` endpoint
- [ ] Add basic logging (slog)
- [ ] Create `cmd/gateway/main.go` entry point
- [ ] Test server starts and responds

**Implementation**:
```go
// internal/server/server.go
package server

type Server struct {
    httpServer *http.Server
    logger     *slog.Logger
}

func New(config Config) *Server {
    mux := http.NewServeMux()
    mux.HandleFunc("/health", handleHealth)

    return &Server{
        httpServer: &http.Server{
            Addr:    config.Address,
            Handler: mux,
        },
        logger: slog.Default(),
    }
}

func (s *Server) Start() error {
    s.logger.Info("starting server", "addr", s.httpServer.Addr)
    return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
    s.logger.Info("shutting down server")
    return s.httpServer.Shutdown(ctx)
}
```

**Acceptance Criteria**:
- âœ… Server starts on port 8080
- âœ… `GET /health` returns 200 OK
- âœ… Graceful shutdown on SIGTERM/SIGINT
- âœ… Logs are structured (JSON)

**Testing**:
```bash
# Unit test
go test ./internal/server/...

# Manual test
./gateway &
curl http://localhost:8080/health
# {"status":"healthy"}

kill -TERM $!
# [INFO] shutting down server
```

---

#### Task 1.3: Configuration Management
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 1.2

**Description**: Implement YAML config loading with env var overrides

**Checklist**:
- [ ] Create `internal/config/config.go`
- [ ] Define Config structs
- [ ] Implement YAML parsing (gopkg.in/yaml.v3)
- [ ] Implement env var overrides
- [ ] Add config validation
- [ ] Create example config file

**Implementation**:
```go
// internal/config/config.go
package config

type Config struct {
    Gateway  GatewayConfig  `yaml:"gateway"`
    Portal   PortalConfig   `yaml:"portal"`
    Auth     AuthConfig     `yaml:"auth"`
    RateLimit RateLimitConfig `yaml:"rate_limit"`
    Logging  LoggingConfig  `yaml:"logging"`
}

func Load(path string) (*Config, error) {
    // 1. Load from YAML file
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }

    var cfg Config
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, err
    }

    // 2. Override with env vars
    cfg.applyEnvOverrides()

    // 3. Validate
    if err := cfg.Validate(); err != nil {
        return nil, err
    }

    return &cfg, nil
}
```

**Acceptance Criteria**:
- âœ… Config loads from YAML file
- âœ… Env vars override YAML values
- âœ… Validation catches missing required fields
- âœ… Example config file works

**Testing**:
```bash
# Create test config
cat > config.test.yaml <<EOF
gateway:
  host: "0.0.0.0"
  port: 8080
portal:
  relay_url: "ws://localhost:4017/relay"
EOF

# Test loading
go test ./internal/config/... -v

# Test env override
GATEWAY_PORT=9090 ./gateway --config config.test.yaml
# Server should start on port 9090
```

---

#### Task 1.4: Portal Client Integration
**Priority**: P0
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 1.3

**Description**: Integrate Portal SDK and implement connection manager

**Checklist**:
- [ ] Add Portal SDK dependency
- [ ] Create `internal/portal/client.go`
- [ ] Implement PortalClientManager
- [ ] Add connection pooling
- [ ] Add automatic reconnection
- [ ] Test connection to Portal relay

**Implementation**:
```go
// internal/portal/manager.go
package portal

import "github.com/loopholelabs/portal/sdk"

type Manager struct {
    relayURL string
    client   *sdk.Client
    pools    map[string]*connectionPool
    mu       sync.RWMutex
}

func NewManager(relayURL string) (*Manager, error) {
    client, err := sdk.NewClient(relayURL)
    if err != nil {
        return nil, err
    }

    return &Manager{
        relayURL: relayURL,
        client:   client,
        pools:    make(map[string]*connectionPool),
    }, nil
}

func (m *Manager) Dial(leaseID string) (net.Conn, error) {
    // Get or create connection pool for this lease
    pool := m.getOrCreatePool(leaseID)

    // Try to get connection from pool
    conn, err := pool.Get()
    if err != nil {
        // Create new connection
        conn, err = m.client.Dial(leaseID)
        if err != nil {
            return nil, err
        }
    }

    return conn, nil
}
```

**Acceptance Criteria**:
- âœ… Portal SDK successfully imported
- âœ… Manager connects to Portal relay
- âœ… Dial() creates E2EE tunnel to lease
- âœ… Connection pooling works (reuses connections)
- âœ… Automatic reconnection on disconnect

**Testing**:
```bash
# Start Portal relay (in another terminal)
cd /path/to/portal
go run cmd/portal-relay/main.go

# Start test backend (in another terminal)
cd /path/to/portal
go run cmd/demo-app/main.go

# Test gateway dial
go test ./internal/portal/... -v
# Should successfully dial to test lease
```

---

#### Task 1.5: Basic HTTP Proxy
**Priority**: P0
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 1.4

**Description**: Implement HTTP proxy handler that forwards requests through Portal

**Checklist**:
- [ ] Create `internal/proxy/handler.go`
- [ ] Parse lease_id from URL path
- [ ] Dial to Portal lease
- [ ] Forward HTTP request through tunnel
- [ ] Stream response back to client
- [ ] Handle errors gracefully

**Implementation**:
```go
// internal/proxy/handler.go
package proxy

type Handler struct {
    portalManager *portal.Manager
    logger        *slog.Logger
}

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Extract lease_id from path: /peer/:lease_id/*
    leaseID, path := h.parseRequest(r)

    // Dial to Portal lease
    conn, err := h.portalManager.Dial(leaseID)
    if err != nil {
        h.logger.Error("failed to dial", "lease_id", leaseID, "error", err)
        http.Error(w, "Backend unavailable", http.StatusBadGateway)
        return
    }
    defer conn.Close()

    // Create new request with modified path
    proxyReq, err := http.NewRequest(r.Method, path, r.Body)
    if err != nil {
        http.Error(w, "Invalid request", http.StatusBadRequest)
        return
    }

    // Copy headers
    proxyReq.Header = r.Header.Clone()

    // Send request through Portal tunnel
    if err := proxyReq.Write(conn); err != nil {
        http.Error(w, "Backend error", http.StatusBadGateway)
        return
    }

    // Read response
    resp, err := http.ReadResponse(bufio.NewReader(conn), proxyReq)
    if err != nil {
        http.Error(w, "Backend error", http.StatusBadGateway)
        return
    }
    defer resp.Body.Close()

    // Copy response to client
    h.copyResponse(w, resp)
}
```

**Acceptance Criteria**:
- âœ… Proxy forwards GET requests
- âœ… Proxy forwards POST requests with body
- âœ… Response status code preserved
- âœ… Response headers preserved
- âœ… Response body streamed correctly
- âœ… Errors return appropriate status codes

**Testing**:
```bash
# Start Portal + backend + gateway

# Test proxy
curl http://localhost:8080/peer/demo-app/
# Should return response from demo-app

# Test with headers
curl -H "X-Custom: value" http://localhost:8080/peer/demo-app/api
# Should forward header to backend

# Test POST
curl -X POST -d '{"test": true}' http://localhost:8080/peer/demo-app/api
# Should forward POST body
```

---

### Week 2: Core Middleware

#### Task 2.1: Middleware Framework
**Priority**: P0
**Effort**: 0.5 days
**Assignee**: TBD
**Dependencies**: Task 1.5

**Description**: Create middleware chaining framework

**Checklist**:
- [ ] Create `pkg/middleware/chain.go`
- [ ] Implement middleware interface
- [ ] Implement middleware chaining
- [ ] Add context value helpers

**Implementation**:
```go
// pkg/middleware/chain.go
package middleware

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) Middleware {
    return func(next http.Handler) http.Handler {
        for i := len(middlewares) - 1; i >= 0; i-- {
            next = middlewares[i](next)
        }
        return next
    }
}

// Usage:
handler := Chain(
    RequestLogger,
    Authentication,
    Authorization,
    RateLimiting,
)(proxyHandler)
```

**Acceptance Criteria**:
- âœ… Middleware executes in correct order
- âœ… Context values propagate correctly
- âœ… Middleware can short-circuit chain

---

#### Task 2.2: Request Logger Middleware
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 2.1

**Description**: Implement request logging middleware with structured logs

**Checklist**:
- [ ] Generate request ID (UUID)
- [ ] Log request start (method, path, headers)
- [ ] Log request completion (status, duration, size)
- [ ] Inject request ID into context
- [ ] Add request ID to response header

**Implementation**:
```go
// internal/middleware/logger.go
package middleware

func RequestLogger(logger *slog.Logger) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            requestID := uuid.New().String()
            start := time.Now()

            // Inject request ID into context
            ctx := context.WithValue(r.Context(), "request_id", requestID)
            r = r.WithContext(ctx)

            // Wrap response writer to capture status
            ww := &responseWriter{ResponseWriter: w, statusCode: 200}

            // Add request ID to response header
            ww.Header().Set("X-Request-ID", requestID)

            // Log request start
            logger.Info("request_started",
                "request_id", requestID,
                "method", r.Method,
                "path", r.URL.Path,
            )

            // Call next handler
            next.ServeHTTP(ww, r)

            // Log request completion
            duration := time.Since(start)
            logger.Info("request_completed",
                "request_id", requestID,
                "method", r.Method,
                "path", r.URL.Path,
                "status", ww.statusCode,
                "duration_ms", duration.Milliseconds(),
                "bytes_sent", ww.bytesWritten,
            )
        })
    }
}
```

**Acceptance Criteria**:
- âœ… Each request gets unique request ID
- âœ… Request start and completion logged
- âœ… Logs include duration and status code
- âœ… Request ID returned in response header

**Testing**:
```bash
curl -v http://localhost:8080/peer/demo-app/
# Should see X-Request-ID in response headers
# Should see structured logs in server output
```

---

#### Task 2.3: Authentication Middleware
**Priority**: P0
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 2.2

**Description**: Implement API key authentication

**Checklist**:
- [ ] Create `internal/auth/manager.go`
- [ ] Implement API key storage (in-memory)
- [ ] Implement key validation (bcrypt)
- [ ] Create authentication middleware
- [ ] Add key info to request context
- [ ] Handle authentication errors

**Implementation**:
```go
// internal/auth/manager.go
package auth

type Manager struct {
    keys map[string]*KeyInfo
    mu   sync.RWMutex
}

type KeyInfo struct {
    KeyHash     string
    Description string
    Scopes      []string
    ExpiresAt   time.Time
    CreatedAt   time.Time
}

func (m *Manager) ValidateKey(key string) (*KeyInfo, error) {
    // Extract key ID (first 16 chars after prefix)
    // sk_live_abc123... -> abc123
    keyID := extractKeyID(key)

    m.mu.RLock()
    keyInfo, exists := m.keys[keyID]
    m.mu.RUnlock()

    if !exists {
        return nil, ErrKeyNotFound
    }

    // Check expiry
    if time.Now().After(keyInfo.ExpiresAt) {
        return nil, ErrKeyExpired
    }

    // Validate key hash
    if err := bcrypt.CompareHashAndPassword(
        []byte(keyInfo.KeyHash),
        []byte(key),
    ); err != nil {
        return nil, ErrKeyInvalid
    }

    return keyInfo, nil
}

// Middleware
func (m *Manager) Middleware() middleware.Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Extract API key from Authorization header
            authHeader := r.Header.Get("Authorization")
            if authHeader == "" {
                http.Error(w, "Missing Authorization header", http.StatusUnauthorized)
                return
            }

            // Parse "Bearer <key>"
            key := strings.TrimPrefix(authHeader, "Bearer ")
            if key == authHeader {
                http.Error(w, "Invalid Authorization format", http.StatusUnauthorized)
                return
            }

            // Validate key
            keyInfo, err := m.ValidateKey(key)
            if err != nil {
                http.Error(w, "Invalid API key", http.StatusUnauthorized)
                return
            }

            // Inject key info into context
            ctx := context.WithValue(r.Context(), "api_key_info", keyInfo)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

**Acceptance Criteria**:
- âœ… Valid API key allows request
- âœ… Invalid API key returns 401
- âœ… Missing Authorization header returns 401
- âœ… Expired key returns 401
- âœ… Key info available in request context

**Testing**:
```bash
# Generate test key
VALID_KEY=$(go run scripts/gen-key.go)

# Test with valid key
curl -H "Authorization: Bearer $VALID_KEY" \
  http://localhost:8080/peer/demo-app/
# Should succeed

# Test without key
curl http://localhost:8080/peer/demo-app/
# Should return 401

# Test with invalid key
curl -H "Authorization: Bearer sk_live_invalid" \
  http://localhost:8080/peer/demo-app/
# Should return 401
```

---

#### Task 2.4: ACL Middleware
**Priority**: P0
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 2.3

**Description**: Implement lease-based access control

**Checklist**:
- [ ] Create `internal/acl/manager.go`
- [ ] Implement ACL storage (in-memory)
- [ ] Implement ACL checking logic
- [ ] Create ACL middleware
- [ ] Support wildcard leases
- [ ] Handle ACL errors

**Implementation**:
```go
// internal/acl/manager.go
package acl

type Manager struct {
    acls map[string][]string  // lease_id -> []api_key_id
    mu   sync.RWMutex
}

func (m *Manager) CheckAccess(leaseID string, keyInfo *auth.KeyInfo) error {
    m.mu.RLock()
    defer m.mu.RUnlock()

    // Check exact match
    allowedKeys, exists := m.acls[leaseID]
    if exists {
        if contains(allowedKeys, keyInfo.KeyID) || contains(allowedKeys, "*") {
            return nil
        }
    }

    // Check wildcard pattern
    for pattern, keys := range m.acls {
        if matchPattern(pattern, leaseID) {
            if contains(keys, keyInfo.KeyID) || contains(keys, "*") {
                return nil
            }
        }
    }

    return ErrAccessDenied
}

// Middleware
func (m *Manager) Middleware() middleware.Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Extract lease_id from path
            leaseID := extractLeaseID(r.URL.Path)

            // Get key info from context (set by auth middleware)
            keyInfo := r.Context().Value("api_key_info").(*auth.KeyInfo)

            // Check access
            if err := m.CheckAccess(leaseID, keyInfo); err != nil {
                http.Error(w, "Access denied", http.StatusForbidden)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

**Acceptance Criteria**:
- âœ… Allowed key can access lease
- âœ… Disallowed key returns 403
- âœ… Wildcard "*" allows all keys
- âœ… Pattern matching works (e.g., "public-*")

**Testing**:
```bash
# Configure ACL: only KEY1 can access "my-mcp"
# KEY1 should succeed
curl -H "Authorization: Bearer $KEY1" \
  http://localhost:8080/peer/my-mcp/api
# Should succeed (200)

# KEY2 should fail
curl -H "Authorization: Bearer $KEY2" \
  http://localhost:8080/peer/my-mcp/api
# Should return 403

# Public lease (wildcard)
curl -H "Authorization: Bearer $KEY2" \
  http://localhost:8080/peer/public-api/status
# Should succeed (200)
```

---

#### Task 2.5: Rate Limiting Middleware
**Priority**: P0
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 2.4

**Description**: Implement token bucket rate limiting

**Checklist**:
- [ ] Create `internal/ratelimit/limiter.go`
- [ ] Implement token bucket algorithm
- [ ] Support per-key rate limits
- [ ] Support global rate limit
- [ ] Create rate limit middleware
- [ ] Add Retry-After header

**Implementation**:
```go
// internal/ratelimit/limiter.go
package ratelimit

import "golang.org/x/time/rate"

type Limiter struct {
    limiters map[string]*rate.Limiter
    config   Config
    mu       sync.RWMutex
}

type Config struct {
    Global    LimitConfig
    PerKey    map[string]LimitConfig
    DefaultPerKey LimitConfig
}

type LimitConfig struct {
    RequestsPerSecond int
    Burst             int
}

func (l *Limiter) Allow(keyID string) (bool, time.Duration) {
    // Check global limit first
    if !l.globalLimiter.Allow() {
        return false, l.retryAfter(l.globalLimiter)
    }

    // Get or create limiter for this key
    limiter := l.getLimiterForKey(keyID)

    if !limiter.Allow() {
        return false, l.retryAfter(limiter)
    }

    return true, 0
}

func (l *Limiter) getLimiterForKey(keyID string) *rate.Limiter {
    l.mu.RLock()
    limiter, exists := l.limiters[keyID]
    l.mu.RUnlock()

    if exists {
        return limiter
    }

    // Create new limiter
    config := l.getConfigForKey(keyID)
    limiter = rate.NewLimiter(
        rate.Limit(config.RequestsPerSecond),
        config.Burst,
    )

    l.mu.Lock()
    l.limiters[keyID] = limiter
    l.mu.Unlock()

    return limiter
}

// Middleware
func (l *Limiter) Middleware() middleware.Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            keyInfo := r.Context().Value("api_key_info").(*auth.KeyInfo)

            allowed, retryAfter := l.Allow(keyInfo.KeyID)
            if !allowed {
                w.Header().Set("Retry-After", strconv.Itoa(int(retryAfter.Seconds())))
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

**Acceptance Criteria**:
- âœ… Requests within limit succeed
- âœ… Requests exceeding limit return 429
- âœ… Retry-After header included
- âœ… Per-key limits enforced independently
- âœ… Global limit applies to all requests

**Testing**:
```bash
# Rapid fire requests (exceed rate limit)
for i in {1..200}; do
  curl -H "Authorization: Bearer $KEY1" \
    http://localhost:8080/peer/demo-app/ &
done
wait

# Should see some 429 responses with Retry-After header
```

---

## ðŸ“… Phase 2: Observability & Reliability (Weeks 3-4)

### Week 3: Metrics & Monitoring

#### Task 3.1: Prometheus Metrics
**Priority**: P0
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 2.5

**Description**: Implement Prometheus metrics collection

**Checklist**:
- [ ] Create `internal/metrics/collector.go`
- [ ] Define core metrics (requests, duration, errors)
- [ ] Create metrics middleware
- [ ] Expose `/metrics` endpoint
- [ ] Test with Prometheus

**Implementation**:
```go
// internal/metrics/collector.go
package metrics

import "github.com/prometheus/client_golang/prometheus"

type Collector struct {
    requestsTotal   *prometheus.CounterVec
    requestDuration *prometheus.HistogramVec
    requestSize     *prometheus.HistogramVec
    responseSize    *prometheus.HistogramVec
    errorsTotal     *prometheus.CounterVec
}

func NewCollector() *Collector {
    c := &Collector{
        requestsTotal: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "portal_gateway_requests_total",
                Help: "Total number of requests",
            },
            []string{"method", "path", "status", "lease_id"},
        ),

        requestDuration: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name: "portal_gateway_request_duration_seconds",
                Help: "Request duration in seconds",
                Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10},
            },
            []string{"method", "path", "lease_id"},
        ),

        // ... more metrics
    }

    // Register metrics
    prometheus.MustRegister(c.requestsTotal)
    prometheus.MustRegister(c.requestDuration)

    return c
}

// Middleware
func (c *Collector) Middleware() middleware.Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()

            ww := &responseWriter{ResponseWriter: w}
            next.ServeHTTP(ww, r)

            duration := time.Since(start).Seconds()
            leaseID := extractLeaseID(r.URL.Path)

            c.requestsTotal.WithLabelValues(
                r.Method,
                r.URL.Path,
                strconv.Itoa(ww.statusCode),
                leaseID,
            ).Inc()

            c.requestDuration.WithLabelValues(
                r.Method,
                r.URL.Path,
                leaseID,
            ).Observe(duration)
        })
    }
}
```

**Acceptance Criteria**:
- âœ… `/metrics` endpoint exposes Prometheus format
- âœ… Request counters increment correctly
- âœ… Duration histograms record latency
- âœ… Metrics include relevant labels (method, path, status, lease_id)
- âœ… Prometheus can scrape metrics

**Testing**:
```bash
# Make some requests
curl http://localhost:8080/peer/demo-app/ -H "Authorization: Bearer $KEY"

# Check metrics
curl http://localhost:8080/metrics | grep portal_gateway
# Should see metrics with values

# Configure Prometheus
cat > prometheus.yml <<EOF
scrape_configs:
  - job_name: 'portal-gateway'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:8080']
EOF

prometheus --config.file=prometheus.yml
# Visit http://localhost:9090 and query metrics
```

---

#### Task 3.2: Structured Logging
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 3.1

**Description**: Enhance logging with structured fields and log levels

**Checklist**:
- [ ] Use slog for structured logging
- [ ] Add contextual fields (request_id, lease_id, etc.)
- [ ] Implement log levels (debug, info, warn, error)
- [ ] Add JSON output format
- [ ] Configure log output (stdout/file)

**Acceptance Criteria**:
- âœ… All logs are structured JSON
- âœ… Logs include relevant context fields
- âœ… Log level filtering works
- âœ… Logs can be sent to stdout or file

---

#### Task 3.3: Circuit Breaker
**Priority**: P1
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 3.2

**Description**: Implement circuit breaker for backend protection

**Checklist**:
- [ ] Create `internal/reliability/circuitbreaker.go`
- [ ] Integrate github.com/sony/gobreaker
- [ ] Track failure rates per lease
- [ ] Implement state transitions (CLOSED â†’ OPEN â†’ HALF_OPEN)
- [ ] Add circuit breaker middleware
- [ ] Expose circuit breaker state in metrics

**Implementation**:
```go
// internal/reliability/circuitbreaker.go
package reliability

import "github.com/sony/gobreaker"

type CircuitBreakerManager struct {
    breakers map[string]*gobreaker.CircuitBreaker
    config   Config
    mu       sync.RWMutex
}

func (m *CircuitBreakerManager) Execute(leaseID string, fn func() error) error {
    breaker := m.getBreakerForLease(leaseID)

    _, err := breaker.Execute(func() (interface{}, error) {
        return nil, fn()
    })

    return err
}

func (m *CircuitBreakerManager) getBreakerForLease(leaseID string) *gobreaker.CircuitBreaker {
    m.mu.RLock()
    breaker, exists := m.breakers[leaseID]
    m.mu.RUnlock()

    if exists {
        return breaker
    }

    // Create new circuit breaker
    breaker = gobreaker.NewCircuitBreaker(gobreaker.Settings{
        Name:        leaseID,
        MaxRequests: m.config.MaxRequests,
        Interval:    m.config.Interval,
        Timeout:     m.config.Timeout,
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
            return counts.Requests >= 3 && failureRatio >= 0.6
        },
    })

    m.mu.Lock()
    m.breakers[leaseID] = breaker
    m.mu.Unlock()

    return breaker
}
```

**Acceptance Criteria**:
- âœ… Circuit opens after threshold failures
- âœ… Open circuit returns 503 immediately
- âœ… Circuit transitions to half-open after timeout
- âœ… Half-open circuit allows test requests
- âœ… Circuit closes after successful test requests
- âœ… Metrics expose circuit breaker state

**Testing**:
```bash
# Stop backend to trigger failures
# Make requests to trigger circuit breaker
for i in {1..10}; do
  curl http://localhost:8080/peer/demo-app/ -H "Authorization: Bearer $KEY"
done

# Should see circuit breaker open (503 Service Unavailable)
# Restart backend and wait for timeout
# Should see circuit transition to half-open then closed
```

---

#### Task 3.4: Request Timeout
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 3.3

**Description**: Add configurable request timeouts

**Checklist**:
- [ ] Create timeout middleware
- [ ] Support per-lease timeout overrides
- [ ] Cancel context on timeout
- [ ] Return 504 Gateway Timeout
- [ ] Track timeout metrics

**Implementation**:
```go
// internal/middleware/timeout.go
package middleware

func Timeout(defaultTimeout time.Duration) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), defaultTimeout)
            defer cancel()

            done := make(chan struct{})
            go func() {
                next.ServeHTTP(w, r.WithContext(ctx))
                close(done)
            }()

            select {
            case <-done:
                // Request completed
            case <-ctx.Done():
                // Request timed out
                http.Error(w, "Gateway Timeout", http.StatusGatewayTimeout)
            }
        })
    }
}
```

**Acceptance Criteria**:
- âœ… Requests complete within timeout
- âœ… Long requests return 504 after timeout
- âœ… Context cancellation propagates to backend
- âœ… Timeout metrics recorded

---

### Week 4: Production Readiness

#### Task 4.1: Docker Image
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 3.4

**Description**: Create production Docker image

**Checklist**:
- [ ] Write multi-stage Dockerfile
- [ ] Use minimal base image (alpine or distroless)
- [ ] Include health check
- [ ] Optimize layer caching
- [ ] Test Docker build
- [ ] Push to container registry

**Implementation**:
```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o gateway cmd/gateway/main.go

FROM alpine:latest

RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/gateway .
COPY configs/config.docker.yaml /etc/gateway/config.yaml

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

CMD ["./gateway", "--config", "/etc/gateway/config.yaml"]
```

**Acceptance Criteria**:
- âœ… Docker image builds successfully
- âœ… Image size < 50MB
- âœ… Container starts and serves requests
- âœ… Health check passes

**Testing**:
```bash
# Build
docker build -t portal-gateway:latest .

# Run
docker run -p 8080:8080 portal-gateway:latest

# Test
curl http://localhost:8080/health
# {"status":"healthy"}

# Check size
docker images portal-gateway
# Should be < 50MB
```

---

#### Task 4.2: Docker Compose Setup
**Priority**: P1
**Effort**: 0.5 days
**Assignee**: TBD
**Dependencies**: Task 4.1

**Description**: Create Docker Compose for local development

**Checklist**:
- [ ] Write docker-compose.yml
- [ ] Include gateway, Prometheus, Grafana
- [ ] Mount config volumes
- [ ] Set up networks
- [ ] Test full stack startup

**Implementation**:
```yaml
# docker-compose.yml
version: '3.8'

services:
  gateway:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - ./configs/config.yaml:/etc/gateway/config.yaml:ro
    environment:
      - GATEWAY_LOG_LEVEL=debug
    networks:
      - gateway-net

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    networks:
      - gateway-net

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    volumes:
      - ./configs/grafana-dashboards:/etc/grafana/provisioning/dashboards:ro
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    networks:
      - gateway-net

networks:
  gateway-net:
```

**Acceptance Criteria**:
- âœ… `docker-compose up` starts all services
- âœ… Gateway accessible at localhost:8080
- âœ… Prometheus accessible at localhost:9090
- âœ… Grafana accessible at localhost:3000

---

#### Task 4.3: Grafana Dashboards
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 4.2

**Description**: Create Grafana dashboards for monitoring

**Checklist**:
- [ ] Create "Overview" dashboard
- [ ] Create "Performance" dashboard
- [ ] Create "Errors" dashboard
- [ ] Add alerting rules
- [ ] Export dashboard JSON

**Dashboard Panels**:
- Request rate (req/s)
- P50/P95/P99 latency
- Error rate
- Status code breakdown
- Top leases by traffic
- Circuit breaker states
- Rate limit rejections

**Acceptance Criteria**:
- âœ… Dashboards load in Grafana
- âœ… Panels show real data
- âœ… Alerts trigger on errors
- âœ… Dashboards can be imported from JSON

---

#### Task 4.4: Documentation
**Priority**: P1
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 4.3

**Description**: Write comprehensive user documentation

**Checklist**:
- [ ] Update README.md with quickstart
- [ ] Write configuration guide
- [ ] Write deployment guide
- [ ] Write troubleshooting guide
- [ ] Write API reference
- [ ] Add usage examples

**Documentation Structure**:
```
docs/
â”œâ”€â”€ README.md              # Overview & quickstart
â”œâ”€â”€ getting-started.md     # Installation & first request
â”œâ”€â”€ configuration.md       # Config reference
â”œâ”€â”€ deployment/
â”‚   â”œâ”€â”€ docker.md
â”‚   â”œâ”€â”€ kubernetes.md
â”‚   â””â”€â”€ cloud.md
â”œâ”€â”€ guides/
â”‚   â”œâ”€â”€ authentication.md
â”‚   â”œâ”€â”€ rate-limiting.md
â”‚   â””â”€â”€ monitoring.md
â”œâ”€â”€ api-reference.md       # HTTP API docs
â””â”€â”€ troubleshooting.md     # Common issues
```

**Acceptance Criteria**:
- âœ… New user can follow quickstart to first request
- âœ… All config options documented
- âœ… Deployment guides cover Docker, K8s, cloud
- âœ… API reference includes examples
- âœ… Troubleshooting covers common issues

---

#### Task 4.5: Integration Tests
**Priority**: P1
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 4.4

**Description**: Write end-to-end integration tests

**Checklist**:
- [ ] Set up test environment (testcontainers)
- [ ] Write auth flow tests
- [ ] Write proxy tests
- [ ] Write rate limiting tests
- [ ] Write error handling tests
- [ ] Add CI pipeline

**Test Scenarios**:
```go
// tests/integration/gateway_test.go
package integration

func TestAuthenticationFlow(t *testing.T) {
    // 1. Start gateway + Portal + backend
    // 2. Test valid API key succeeds
    // 3. Test invalid API key fails with 401
    // 4. Test expired key fails with 401
}

func TestProxyFlow(t *testing.T) {
    // 1. Make GET request through gateway
    // 2. Verify response matches backend
    // 3. Make POST request with body
    // 4. Verify body forwarded correctly
}

func TestRateLimiting(t *testing.T) {
    // 1. Make requests within limit
    // 2. Exceed limit
    // 3. Verify 429 response
    // 4. Verify Retry-After header
}
```

**Acceptance Criteria**:
- âœ… All integration tests pass
- âœ… Tests can run in CI
- âœ… Coverage > 80%
- âœ… Tests run in < 2 minutes

---

## ðŸ“… Phase 3: MVP Release (Weeks 5-6)

### Week 5: Polish & Testing

#### Task 5.1: Load Testing
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 4.5

**Description**: Perform load testing to validate performance

**Checklist**:
- [ ] Write load test scenarios (k6 or vegeta)
- [ ] Test sustained load (1000 req/s for 10 min)
- [ ] Test spike load (0 â†’ 5000 req/s)
- [ ] Measure latency (P50, P95, P99)
- [ ] Identify bottlenecks
- [ ] Document performance characteristics

**Load Test Script**:
```javascript
// loadtest.js (k6)
import http from 'k6/http';

export let options = {
  stages: [
    { duration: '2m', target: 100 },    // Ramp up
    { duration: '5m', target: 1000 },   // Sustained
    { duration: '2m', target: 0 },      // Ramp down
  ],
};

export default function () {
  let response = http.get('http://localhost:8080/peer/demo-app/', {
    headers: { 'Authorization': 'Bearer sk_live_test...' },
  });
  check(response, { 'status is 200': (r) => r.status === 200 });
}
```

**Acceptance Criteria**:
- âœ… Gateway handles 1000 req/s sustained
- âœ… P95 latency < 100ms
- âœ… Error rate < 0.1%
- âœ… No memory leaks
- âœ… Performance report created

---

#### Task 5.2: Security Audit
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 5.1

**Description**: Perform basic security audit

**Checklist**:
- [ ] Review authentication implementation
- [ ] Check for injection vulnerabilities
- [ ] Verify TLS configuration
- [ ] Check secrets management
- [ ] Review error messages (no sensitive data)
- [ ] Run static analysis tools (gosec)
- [ ] Document security findings

**Security Checks**:
```bash
# Static analysis
gosec ./...

# Dependency vulnerabilities
go list -json -m all | nancy sleuth

# TLS configuration
testssl.sh https://localhost:8443

# API security
OWASP ZAP scan
```

**Acceptance Criteria**:
- âœ… No critical vulnerabilities found
- âœ… TLS configured properly (TLS 1.3)
- âœ… API keys stored securely (bcrypt)
- âœ… No sensitive data in logs
- âœ… Security findings documented

---

#### Task 5.3: Bug Fixes & Polish
**Priority**: P1
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 5.2

**Description**: Fix bugs found during testing and polish UX

**Checklist**:
- [ ] Fix bugs from integration tests
- [ ] Fix bugs from load testing
- [ ] Fix bugs from security audit
- [ ] Improve error messages
- [ ] Add input validation
- [ ] Polish logs

**Acceptance Criteria**:
- âœ… All known bugs fixed
- âœ… Error messages are clear and actionable
- âœ… Input validation prevents crashes
- âœ… Logs are clean and informative

---

#### Task 5.4: Release Preparation
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 5.3

**Description**: Prepare for v0.1.0 MVP release

**Checklist**:
- [ ] Update CHANGELOG.md
- [ ] Tag release (v0.1.0)
- [ ] Build release binaries (Linux, macOS, Windows)
- [ ] Create GitHub release
- [ ] Push Docker image to registry
- [ ] Announce release

**Release Artifacts**:
- Binary: `portal-gateway-v0.1.0-linux-amd64`
- Binary: `portal-gateway-v0.1.0-darwin-amd64`
- Binary: `portal-gateway-v0.1.0-windows-amd64.exe`
- Docker: `portal-gateway:0.1.0`, `portal-gateway:latest`

**Acceptance Criteria**:
- âœ… GitHub release created
- âœ… Release notes published
- âœ… Binaries work on all platforms
- âœ… Docker image available
- âœ… Announcement posted

---

### Week 6: MVP Validation & Feedback

#### Task 6.1: User Testing
**Priority**: P0
**Effort**: 3 days
**Assignee**: TBD
**Dependencies**: Task 5.4

**Description**: Get feedback from early users

**Checklist**:
- [ ] Recruit 5-10 early testers
- [ ] Provide quickstart guide
- [ ] Monitor usage (anonymized metrics)
- [ ] Collect feedback
- [ ] Identify pain points
- [ ] Prioritize improvements

**Feedback Channels**:
- GitHub Discussions
- Discord server
- Email survey

**Acceptance Criteria**:
- âœ… 5+ users successfully deployed
- âœ… Feedback collected and analyzed
- âœ… Top 3 pain points identified
- âœ… Improvement roadmap updated

---

#### Task 6.2: Bug Fix Cycle
**Priority**: P0
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 6.1

**Description**: Fix bugs reported by early users

**Checklist**:
- [ ] Triage bug reports
- [ ] Fix critical bugs
- [ ] Release v0.1.1 patch

**Acceptance Criteria**:
- âœ… Critical bugs fixed
- âœ… Patch release published
- âœ… Users confirm fixes work

---

## ðŸ“… Phase 4: AI Optimization (Weeks 7-8)

### Week 7: Caching & Streaming

#### Task 7.1: Response Caching
**Priority**: P1
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 6.2

**Description**: Implement intelligent response caching

**Checklist**:
- [ ] Create cache manager (in-memory LRU)
- [ ] Implement cache key generation
- [ ] Add cache lookup to proxy handler
- [ ] Support cache-control headers
- [ ] Add cache metrics
- [ ] Test cache hit/miss

**Implementation**:
```go
// internal/cache/manager.go
package cache

type Manager struct {
    cache *cache.Cache
}

func (m *Manager) Get(key string) ([]byte, bool) {
    val, found := m.cache.Get(key)
    if !found {
        return nil, false
    }
    return val.([]byte), true
}

func (m *Manager) Set(key string, value []byte, ttl time.Duration) {
    m.cache.Set(key, value, ttl)
}

func generateCacheKey(leaseID, path string, headers http.Header) string {
    h := sha256.New()
    h.Write([]byte(leaseID))
    h.Write([]byte(path))
    // Include relevant headers
    h.Write([]byte(headers.Get("Accept")))
    return hex.EncodeToString(h.Sum(nil))
}
```

**Acceptance Criteria**:
- âœ… GET requests cached when appropriate
- âœ… Cache-Control headers respected
- âœ… Cache hit rate > 20% for typical workloads
- âœ… Metrics track cache hits/misses

---

#### Task 7.2: SSE Streaming Support
**Priority**: P2
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 7.1

**Description**: Add Server-Sent Events (SSE) streaming support

**Checklist**:
- [ ] Detect SSE requests (Accept: text/event-stream)
- [ ] Implement streaming proxy
- [ ] Add Flusher support
- [ ] Handle connection drops
- [ ] Test with streaming endpoint

**Implementation**:
```go
// internal/proxy/sse.go
package proxy

func (h *Handler) handleSSE(w http.ResponseWriter, r *http.Request, conn net.Conn) {
    // Set SSE headers
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }

    // Stream response
    reader := bufio.NewReader(conn)
    for {
        line, err := reader.ReadBytes('\n')
        if err != nil {
            if err != io.EOF {
                h.logger.Error("stream error", "error", err)
            }
            break
        }

        w.Write(line)
        flusher.Flush()
    }
}
```

**Acceptance Criteria**:
- âœ… SSE requests stream correctly
- âœ… Data flushed immediately
- âœ… Connection kept alive
- âœ… Handles client disconnect gracefully

---

#### Task 7.3: WebSocket Proxy
**Priority**: P2
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 7.2

**Description**: Add WebSocket proxying support

**Checklist**:
- [ ] Detect WebSocket upgrade requests
- [ ] Perform WebSocket handshake
- [ ] Implement bidirectional proxy
- [ ] Handle ping/pong frames
- [ ] Test with WebSocket endpoint

**Implementation**:
```go
// internal/proxy/websocket.go
package proxy

func (h *Handler) handleWebSocket(w http.ResponseWriter, r *http.Request, leaseID string) {
    // Upgrade client connection
    clientConn, err := h.upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    defer clientConn.Close()

    // Dial to backend
    backendConn, err := h.portalManager.Dial(leaseID)
    if err != nil {
        clientConn.WriteMessage(websocket.CloseMessage, []byte("Backend unavailable"))
        return
    }
    defer backendConn.Close()

    // Bidirectional proxy
    errChan := make(chan error, 2)

    // Client â†’ Backend
    go func() {
        _, err := io.Copy(backendConn, &wsReader{clientConn})
        errChan <- err
    }()

    // Backend â†’ Client
    go func() {
        _, err := io.Copy(&wsWriter{clientConn}, backendConn)
        errChan <- err
    }()

    // Wait for either direction to close
    <-errChan
}
```

**Acceptance Criteria**:
- âœ… WebSocket upgrade succeeds
- âœ… Messages forwarded bidirectionally
- âœ… Ping/pong frames handled
- âœ… Connection closes gracefully

---

### Week 8: Advanced Features

#### Task 8.1: Request Retry Logic
**Priority**: P2
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 7.3

**Description**: Add automatic retry for failed requests

**Checklist**:
- [ ] Implement retry logic (exponential backoff)
- [ ] Configure retry limits
- [ ] Only retry idempotent requests
- [ ] Track retry metrics
- [ ] Test retry behavior

**Acceptance Criteria**:
- âœ… Failed requests retry automatically
- âœ… Exponential backoff between retries
- âœ… Non-idempotent requests not retried
- âœ… Max retry limit enforced

---

#### Task 8.2: Multi-Portal HA Support
**Priority**: P2
**Effort**: 3 days
**Assignee**: TBD
**Dependencies**: Task 8.1

**Description**: Support multiple Portal relays for high availability

**Checklist**:
- [ ] Support multiple relay URLs in config
- [ ] Implement relay selection (round-robin)
- [ ] Implement failover on relay failure
- [ ] Add relay health checking
- [ ] Test HA scenario

**Implementation**:
```go
// internal/portal/ha_manager.go
package portal

type HAManager struct {
    relays  []*RelayClient
    current int
    mu      sync.RWMutex
}

func (m *HAManager) Dial(leaseID string) (net.Conn, error) {
    for i := 0; i < len(m.relays); i++ {
        relay := m.getCurrentRelay()

        conn, err := relay.Dial(leaseID)
        if err != nil {
            // Try next relay
            m.rotateRelay()
            continue
        }

        return conn, nil
    }

    return nil, ErrAllRelaysFailed
}
```

**Acceptance Criteria**:
- âœ… Gateway connects to multiple relays
- âœ… Failover works when relay goes down
- âœ… Round-robin distributes load
- âœ… Metrics track relay health

---

## ðŸ“… Phase 5: Production Hardening (Weeks 9-10)

### Week 9: Kubernetes & Deployment

#### Task 9.1: Kubernetes Manifests
**Priority**: P1
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 8.2

**Description**: Create production Kubernetes manifests

**Checklist**:
- [ ] Create Deployment manifest
- [ ] Create Service manifest
- [ ] Create ConfigMap manifest
- [ ] Create Secret management
- [ ] Create Ingress manifest
- [ ] Create HPA (Horizontal Pod Autoscaler)
- [ ] Test on Kubernetes cluster

**Acceptance Criteria**:
- âœ… Gateway deploys to Kubernetes
- âœ… Service accessible via LoadBalancer
- âœ… Config loaded from ConfigMap
- âœ… Secrets loaded securely
- âœ… HPA scales based on load

---

#### Task 9.2: Helm Chart
**Priority**: P2
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 9.1

**Description**: Create Helm chart for easy deployment

**Checklist**:
- [ ] Create Helm chart structure
- [ ] Parameterize manifests
- [ ] Add values.yaml
- [ ] Test installation
- [ ] Publish to Helm repository

**Acceptance Criteria**:
- âœ… `helm install` deploys gateway
- âœ… All resources created correctly
- âœ… Values.yaml documented
- âœ… Chart published

---

#### Task 9.3: Deployment Guides
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 9.2

**Description**: Write deployment guides for different platforms

**Guides**:
- Docker deployment
- Kubernetes deployment
- AWS ECS deployment
- Google Cloud Run deployment

**Acceptance Criteria**:
- âœ… Each guide complete with examples
- âœ… Guides tested on actual platforms
- âœ… Common issues documented

---

### Week 10: Operations & Maintenance

#### Task 10.1: Operational Runbook
**Priority**: P1
**Effort**: 1.5 days
**Assignee**: TBD
**Dependencies**: Task 9.3

**Description**: Create operational runbook for production

**Sections**:
- System overview
- Common operations (start, stop, restart, upgrade)
- Troubleshooting guide
- Alerting rules
- Incident response
- Backup and recovery
- Performance tuning

**Acceptance Criteria**:
- âœ… Runbook covers all common operations
- âœ… Troubleshooting steps validated
- âœ… Alert rules documented
- âœ… Incident response procedures defined

---

#### Task 10.2: Monitoring Alerts
**Priority**: P1
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 10.1

**Description**: Set up production alerting rules

**Alerts**:
```yaml
# prometheus-alerts.yml
groups:
  - name: gateway
    rules:
      - alert: HighErrorRate
        expr: rate(portal_gateway_errors_total[5m]) > 0.01
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"

      - alert: HighLatency
        expr: histogram_quantile(0.95, portal_gateway_request_duration_seconds) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected (P95 > 1s)"

      - alert: PortalDisconnected
        expr: portal_gateway_portal_connected == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Portal relay disconnected"
```

**Acceptance Criteria**:
- âœ… Alerts defined for critical issues
- âœ… Alerts tested (trigger intentionally)
- âœ… Alert notifications work (email, Slack, PagerDuty)
- âœ… Alert runbook linked

---

#### Task 10.3: Performance Optimization
**Priority**: P2
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 10.2

**Description**: Profile and optimize performance

**Checklist**:
- [ ] Profile CPU usage (pprof)
- [ ] Profile memory usage
- [ ] Identify hot paths
- [ ] Optimize critical paths
- [ ] Reduce allocations
- [ ] Benchmark improvements

**Acceptance Criteria**:
- âœ… CPU usage reduced by 10%+
- âœ… Memory allocations reduced
- âœ… Latency improved by 10%+
- âœ… Benchmarks show improvements

---

## ðŸ“… Phase 6: Enterprise Features (Weeks 11-12)

### Week 11: Advanced Authentication

#### Task 11.1: JWT Support
**Priority**: P2
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 10.3

**Description**: Add JWT token authentication

**Checklist**:
- [ ] Add JWT library (golang-jwt)
- [ ] Support HMAC and RSA signatures
- [ ] Validate JWT claims
- [ ] Extract user info from JWT
- [ ] Support JWT in Authorization header

**Acceptance Criteria**:
- âœ… JWT tokens validated correctly
- âœ… Expired tokens rejected
- âœ… Invalid signatures rejected
- âœ… Claims extracted and available

---

#### Task 11.2: OAuth2 Integration
**Priority**: P3
**Effort**: 3 days
**Assignee**: TBD
**Dependencies**: Task 11.1

**Description**: Add OAuth2 provider integration

**Checklist**:
- [ ] Support authorization code flow
- [ ] Support OAuth2 token introspection
- [ ] Support multiple OAuth providers
- [ ] Cache token validation
- [ ] Document OAuth setup

**Acceptance Criteria**:
- âœ… OAuth2 tokens validated
- âœ… Multiple providers supported
- âœ… Token introspection works
- âœ… Setup guide complete

---

### Week 12: Enterprise Features

#### Task 12.1: Audit Logging
**Priority**: P2
**Effort**: 2 days
**Assignee**: TBD
**Dependencies**: Task 11.2

**Description**: Implement detailed audit logging

**Checklist**:
- [ ] Log all authentication events
- [ ] Log all authorization decisions
- [ ] Log configuration changes
- [ ] Support audit log export
- [ ] Comply with audit standards

**Acceptance Criteria**:
- âœ… All security events logged
- âœ… Audit logs tamper-evident
- âœ… Audit logs exportable
- âœ… Compliance requirements met

---

#### Task 12.2: Multi-Tenancy Support
**Priority**: P3
**Effort**: 3 days
**Assignee**: TBD
**Dependencies**: Task 12.1

**Description**: Add multi-tenant support

**Checklist**:
- [ ] Support tenant isolation
- [ ] Per-tenant API keys
- [ ] Per-tenant rate limits
- [ ] Per-tenant metrics
- [ ] Tenant management API

**Acceptance Criteria**:
- âœ… Tenants isolated from each other
- âœ… Per-tenant configuration works
- âœ… Per-tenant metrics tracked
- âœ… Management API functional

---

#### Task 12.3: v1.0.0 Release
**Priority**: P0
**Effort**: 1 day
**Assignee**: TBD
**Dependencies**: Task 12.2

**Description**: Release production-ready v1.0.0

**Checklist**:
- [ ] Update CHANGELOG for v1.0.0
- [ ] Tag v1.0.0 release
- [ ] Build release artifacts
- [ ] Update documentation
- [ ] Announce release
- [ ] Celebrate! ðŸŽ‰

**Acceptance Criteria**:
- âœ… v1.0.0 released to GitHub
- âœ… Docker image published
- âœ… Documentation complete
- âœ… Announcement published

---

## ðŸ“Š Progress Tracking

### Sprint Overview

| Week | Phase | Focus | Tasks | Status |
|------|-------|-------|-------|--------|
| 1 | Foundation | Project setup & basic proxy | 5 | â³ Pending |
| 2 | Foundation | Core middleware | 5 | â³ Pending |
| 3 | Observability | Metrics & reliability | 4 | â³ Pending |
| 4 | Production | Docker, docs, tests | 5 | â³ Pending |
| 5 | MVP Release | Testing & release | 4 | â³ Pending |
| 6 | MVP Release | User feedback | 2 | â³ Pending |
| 7 | AI Optimization | Caching & streaming | 3 | â³ Pending |
| 8 | AI Optimization | Advanced features | 2 | â³ Pending |
| 9 | Production | Kubernetes | 3 | â³ Pending |
| 10 | Production | Operations | 3 | â³ Pending |
| 11 | Enterprise | Advanced auth | 2 | â³ Pending |
| 12 | Enterprise | Multi-tenancy & v1.0 | 3 | â³ Pending |

### Effort Summary

| Phase | Tasks | Estimated Days | Target Completion |
|-------|-------|----------------|-------------------|
| Phase 1: Foundation | 10 | 12 | Week 2 |
| Phase 2: Observability | 9 | 10 | Week 4 |
| Phase 3: MVP Release | 6 | 9 | Week 6 |
| Phase 4: AI Optimization | 5 | 9 | Week 8 |
| Phase 5: Production | 6 | 9 | Week 10 |
| Phase 6: Enterprise | 6 | 11 | Week 12 |
| **Total** | **42 tasks** | **60 days** | **12 weeks** |

---

## ðŸŽ¯ Definition of Done

### For Each Task

- [ ] Code implemented and committed
- [ ] Unit tests written (>80% coverage)
- [ ] Integration tests passing
- [ ] Documentation updated
- [ ] Code reviewed by peer
- [ ] No critical bugs
- [ ] Deployed to staging
- [ ] Acceptance criteria met

### For Each Phase

- [ ] All tasks completed
- [ ] Phase acceptance criteria met
- [ ] Documentation complete
- [ ] Demos recorded
- [ ] Stakeholder approval
- [ ] Ready for next phase

### For Release

- [ ] All features implemented
- [ ] All tests passing
- [ ] Performance benchmarks met
- [ ] Security audit passed
- [ ] Documentation complete
- [ ] Release notes written
- [ ] Artifacts built and published
- [ ] Announcement published

---

## ðŸš€ Quick Start (For Implementation Team)

### Week 1 Checklist

```bash
# Day 1: Project setup
git clone <repo>
cd portal-gateway
make init
make build
make test

# Day 2: HTTP server
make run
curl http://localhost:8080/health

# Day 3: Configuration
./gateway --config config.yaml

# Day 4: Portal integration
# Start Portal relay
# Test dial to lease

# Day 5: Basic proxy
curl http://localhost:8080/peer/demo-app/
```

### Daily Standup Format

**What did you do yesterday?**
- Task X.Y: Description
- Status: In progress / Blocked / Done

**What will you do today?**
- Task X.Y: Description
- Estimated time: X hours

**Any blockers?**
- Issue with dependency Z
- Need help with feature W

---

**Document Version**: 1.0
**Last Updated**: 2025-11-14 02:16:31
**Next Review**: Weekly during implementation

**Status**: âœ… Todo List Finalized - Ready for Execution

---

**Note**: This is a living document. Update task status, add newly discovered tasks, and adjust estimates as the project progresses.
